\documentclass[a4paper,12pt,titlepage,twosided]{article}

\usepackage{amsmath}		% For math symbols
\usepackage{xcolor, graphicx}		% For including images

% for code segments
\usepackage{fancyvrb}	
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}

\begin{document}

\title{Modelling/Geometric Transformations}

\author{Rajat Khanduja \\
	09010137 \\
	\and
	Bharat Khatri\\
	09010164}
\date{} %For empty date !

\maketitle

\tableofcontents
\pagebreak

\section{Modelling Transformations}
	Changes in orientation, size and shape are accomplished with Geometric transformations that alter the co-ordinate description of objects. The basic geometric transformations are :- \\
	\begin{itemize}
		\item Translation
		\item Scaling
		\item Rotation
		\item Reflection
		\item Shear
	\end{itemize}

	\subsection{OpenGL examples}
	In the text that follows, we use some OpenGL examples to illustrate how the transformations are performed using OpenGL functions. All transformations are being applied to a square of edge length 1 centred at (0,0), unless stated otherwise. 	
\\
	Following is the part of the code to construct the square in discussion. 
	\begin{code}
		glPushMatrix ();
		glBegin (GL_POLYGON);
		glVertex2f (-0.5, -0.5);
		glVertex2f (-0.5, 0.5 );
		glVertex2f ( 0.5, 0.5 );
		glVertex2f ( 0.5, -0.5);
		glEnd ();
		glPopMatrix ();
	\end{code}
	
	In the discussions that follow, only the transformation code is provided which has to be used before plotting the vertices (\emph{glVertex2f}) but after pushing the matrix using \emph{glPushMatrix}
	\begin{figure}
		\centering
		\includegraphics[height=80mm]{Images_final/Square.jpg}
		\caption{A square drawn using OpenGL.}
		\label{fig:simple_square}
	\end{figure}
	
\pagebreak
\section{Translation}
	\subsection{Introduction}
	A \emph{translation} is applied to an object by repositioning it along a straight line path from one coordinate location to another. Mathematically, translation is achieved by adding the translation distance, $t_x$ and $t_y$, to the original coordinate position $(x,y)$ to move to the new position $(x^{'},y^{'})$.
	\begin{equation*}
		x^{'} = x + t_x
	\end{equation*}
	\begin{equation*}
		y^{'} = y + t_y
	\end{equation*}
	Translation can be achieved by the following transformation :-\\
	\\
	For 2D translation :-
	\begin {equation*}
		\begin{bmatrix}
			1 & 0 & 0 & t_x \\
			0 & 1 & 0 & t_y \\
			0 & 0 & 1 & 0 \\
			0 & 0 & 0 & 1
		\end{bmatrix}
	\end{equation*}
	\\
	For 3D translation :-
	\begin {equation}
		\begin{bmatrix}
			1 & 0 & 0 & t_x \\
			0 & 1 & 0 & t_y \\
			0 & 0 & 1 & t_z \\
			0 & 0 & 0 & 1
			\label{translation_eq}
		\end{bmatrix}
	\end{equation}
%\begin {equation*}
%	\begin{bmatrix}
		
	\subsection{Translation in OpenGL}
		\begin{figure}
			\centering
			\includegraphics[height=80mm]{Images_final/Translated_square.jpg}
			\caption{Translated square}
			\label{fig:translated}
		\end{figure}
		Translation can be achieved in OpenGL using the function \emph{glTranslate}. \\ \\
		The same could be achieved using the transformation matrix described in \eqref{translation_eq}.
		\begin{code}
			// Column major matrix.
			GLdouble t_x = 1;
			GLdouble t_y = 1;
			GLdouble t_z = 0;
			GLdouble translation_matrix[] = { 1, 0, 0, 0,
							  0, 1, 0, 0,
							  0, 0, 1, 0,
							  t_x, t_y, t_z, 1};	

			glMultMatrix (translation_matrix);
		\end{code}
		The effect of the same can be seen in Figure ~\ref{fig:translated}.
	
		
\pagebreak
\pagebreak
\section{Scaling}
	\subsection{Introduction}
	\emph{Scaling} a coordinate means multiplying each of its components by a scalar. The operation can be carried out for polygons by multiplying the coordinate values $(x,y)$ of each vertex by scaling factors $s_x$ and $s_y$ to produce the transformed coordinates $(x^{'},y^{'})$ :-
	\begin{equation*}
		x^{'} = x \cdot s_x 
	\end{equation*}
	\begin{equation*}
		y^{'} = y \cdot s_y
	\end{equation*}
	\begin{equation*}
		z^{'} = z \cdot s_z
	\end{equation*}

	When $s_x$ and $s_y$ (and $s_z$ in case of 3D scaling) are equal, it is called \textbf{uniform scaling}. This can be represented in the form of the following transformation :-
	\begin {equation}
		\begin{bmatrix}
			c & 0 & 0 & 0 \\
			0 & c & 0 & 0 \\
			0 & 0 & c & 0 \\
			0 & 0 & 0 & 1
		\end{bmatrix}
		\\ where\, c = s_x = s_y = s_z
		\label{eq:scaling}
	\end{equation}

	When $s_x$, $s_y$ and $s_z$ are unequal, it is called \textbf{differential scaling}.

	\begin{figure}
		\includegraphics[height=80mm]{Images_final/Square_scaled.jpg}
		\caption{Uniform scaling in OpenGL}
		\label{fig:uniform_scaling}
	\end{figure}

	\subsection{Scaling in OpenGL}
	Scaling could be achieved in OpenGL using \emph{glScale} function.\\ \\
	The same could be achieved multiplying it with a matrix as in \eqref{eq:scaling}. The code for the same is as follows :-
	\begin{code}
		GLdouble c   = 3;
		GLdouble scale_matrix[] = { c, 0, 0, 0, 
					    0, c, 0, 0,
					    0, 0, 1, 0, 
					    0, 0, 0, 1};
		glMultMatrixd (scale_matrix);
	\end{code}

	An example of differential scaling is Figure : \ref{fig:differential_scaling}.
	\begin{figure}
		\includegraphics[height=80mm]{Images_final/Square_non_uniform_scaling.jpg}
		\caption{Differential Scaling in OpenGL}
		\label{fig:differential_scaling}
	\end{figure}

\pagebreak
\section{2D Rotation}
	\subsection{Introduction}
	A \emph{2D Rotation} is applied to an object by repositioning it along a circular path in any of the three x-y, y-z or z-x planes. Rotation in x-y plane, for instance, can be achieved by the following transformation :-
	\begin{equation}
		\begin{bmatrix}
			cos \theta & -sin \theta \\
			sin \theta &  cos \theta 
		\end{bmatrix}
	\end{equation}

	\subsection {Rotation using OpenGL}

	\begin{code}
		GLdouble theta = (3.1415 / 4);		// (\pi)/4
		GLdouble rotation_matrix_z[] = { cos(theta), sin(theta), 0, 0, 
						-sin(theta), cos(theta), 0, 0, 
						0, 0, 1, 0,
						0, 0, 0, 1 };

		glMultMatrixd (rotation_matrix_z);
	\end{code}

	\begin{figure}
		\includegraphics[height=80mm]{Images_final/Rotated_square.jpg}
		\caption{Rotation in OpenGL}
		\label{fig:rotation}
	\end{figure}
\pagebreak
\section{Reflection}
A \emph{reflection} is a transformation that produces the mirror image of an object relative to an axis of reflection by rotating the object $180^\circ$ about the reflection axis. 
\pagebreak
\section{Shear}
A \emph{transformation} that distorts the shape of an object such that the transformed shape appears as if the object were composed of internal layers that had been caused to slide over each other.

\pagebreak

\end{document}
